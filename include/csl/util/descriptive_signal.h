///
/// \file       descriptive_signal.h
/// \author     Menno Valkema <menno.valkema@nlcsl.com>
/// \date       2015-07-17 14:49:01 +0200
///
/// \copyright  Copyright (C) 2015 Cyber Security Labs B.V. The Netherlands.
///
/// \license    This file is part of libcsl, which is distributed
///             under the terms of the GNU Affero General Public License version 3.
///
/// \brief      Extension of the Genode signalling implementation in order
///             ide information with the signal given.
///

#pragma once

#include <root/component.h>
#include <base/attached_rom_dataspace.h>
#include <os/server.h>

#include <csl/util/stdint.h>

namespace Csl
{
	///
	/// Descriptive_signals solve the problem where a standard signal
	/// isn't sufficient when more informatino is required about the
	/// signal reason the signal is sent. Examples can be where a crypto
	/// key expires and a new one needs to be generated by another
	/// component. Another is a TS cache miss, where IKE should be
	/// notified. Descryptions can be of multiple types, therefore the use
	/// of a template.
	///
	/// Usage is straightforward:
	/// \verbatim
	/// In shared.h
	/// ... snip ..
	/// #include <csl/util/descriptive_signal.h>
	///
	/// typedef Csl::Descriptive_signal<Key_id> Key_expiration_signal;
	/// ... snip ...
	///
	/// In server.cc (usecase: has a soon-to-be expiring key, which needs to be
	/// replaced re-gerenarted by the client);
	///
	/// ...snip...
	///
	/// const size_t STACK_SIZE = 4096;
	/// Genode::Cap_connection cap;
	/// static Genode::Sliced_heap sliced_heap(env()->ram_session(),
	///						       env()->rm_session());
	/// Genode::Rpc_entrypoint signal_entry(&cap, STACK_SIZE, "key_expired");
	///
	/// Key_expiration_signal::Transmitter expiration_signal_transmitter(&signal_entry, &sliced_heap);
	///
	/// ...snip...
	///
	/// if(key.expires_soon()){
	///   expiration_signal_transmitter.submit(key.id());
	/// }
	/// ...snip...
	///
	/// In client.cc (usecase: needs to arrange a new key to be generated whenever a signal comes in)
	///
	/// ...snip...
	///  Key_expiration_signal::Receiver expiration_signal_receiver;
	///  while(true) {
	///    expiration_signal_receiver.wait_and_handle([](const Key_expiration_signal::description_t &key_id){
	///      HSM::instance().regenerate_key(key_id); // key_id was transmitted by the server.
	///   });
	/// }
	///
	/// ...snip...
	///
	/// \endverbatim
	///
	/// In order to transmit signals with a description (thus some
	/// payload) a combinationt of Genode rpc and Genode signals are
	/// used. The transmitter sets up RPC endpoint, where payloads can be
	/// retrieved by the client. Once a signal is given, the payload of
	/// the signal is stored, and a Genode Signal is sent to client. The
	/// client then retrieves this payload via RPC.
	///

	template<typename T, const int MAX_SIZE = 32>
	struct Descriptive_signal
	{
		private:
			///
			/// In memory roundrobbin queue for queuing signal.
			/// Starting with a size, follewed by an array of T's.
			///
			class Signal_queue
			{
					Csl::size_t _size;
					T _queue[0];
				public:

					/// Add a signal to the queue. Round
					/// robbin assures the server memory
					/// never overflows, and thus signals
					/// get lost whenever the client isn't
					/// fast enough.
					///
					/// \param signal Signal to add to queue
					///
					void add( const T &signal )
					{
						_queue[_size % MAX_SIZE] = signal;
						_size++;
					}

					///
					/// Empty the queue. Thus set the size to 0, so that
					///
					void clear()
					{
						_size = 0;
						Genode::memset( _queue, 0, REQUIRED_SIZE );
					}

					/// Fetch a new element from the stack
					///
					/// \param i counter thats tracks the elements thath ave been fetched
					///
					/// \return  next element
					///
					T get( const Csl::size_t &i ) const
					{
						return _queue[i];
					}

					///
					/// Number of elements in structure
					///
					/// \return the number of elements
					///
					Csl::size_t size() const
					{
						if ( _size > MAX_SIZE )
						{
							return MAX_SIZE;
						}

						return _size;
					}

					/// Assume a scenario where the queue
					/// created in shared memory space;
					/// the size should be allocatoc
					/// upfront, and can be precisely
					/// calculated. This member is used
					/// when allocating the dataspaces.
					///
					static const Csl::size_t REQUIRED_SIZE = sizeof( Signal_queue )  + sizeof(
					            T ) *MAX_SIZE;

			};

		public:

			///
			/// The type of the payload attached to a descriptive signal.
			///
			typedef T description_t;

			///
			/// The transmitter class. Used by the client-programmer in order to
			/// sent signals out.
			///
			class Transmitter
			{
				private:
					///
					/// Signal_queue_component sents
					/// signals from server to the client,
					/// and queue's the description
					/// (data). Retrieval by the client of
					/// data occurs via shared memory
					/// using a Genode Rom_memory_session,
					/// which means RO from a client
					/// perspective. Data can be modified
					/// by the server. Whenever a change
					/// occurs, or new data is available
					/// the client receives a signal. When
					/// the client is ready a new
					/// RO-dataspace is requested. And a
					/// new dataspace with the modfied
					/// data is presented.
					///
					/// Hence 2 dataspaces are used:
					///
					/// _staged: data being actively
					/// modified by the server: new
					/// signals are added to this dataspace
					/// structure.
					///
					/// _shared: this data is readonly and
					/// shared with the client.
					///
					/// Whenever the client requests the
					/// new dataspace with additional
					/// signals of type T, the dataspaces
					/// are swapped. And the new _shared
					/// dataspace is now available for the
					/// client, and the new _staged
					/// dataspace is emptied, and starts
					/// filling up with newly incoming
					/// signals.
					///
					class Signal_queue_component : public Genode::Rpc_object<Genode::Rom_session>
					{
						private:
							Genode::Attached_dataspace _ds0, _ds1, *_staged, *_shared;
							Genode::Signal_transmitter _transmitter;

							inline Signal_queue *_staged_signals()
							{
								return _staged->local_addr<Signal_queue>();
							}

						public:
							Signal_queue_component( Genode::Env &env ):
								_ds0( env.ram().alloc( Signal_queue::REQUIRED_SIZE ) ),
								_ds1( env.ram().alloc( Signal_queue::REQUIRED_SIZE ) ),
								_staged( &_ds0 ), _shared( &_ds1 )
							{

							}


							Genode::Rom_dataspace_capability dataspace() override
							{
								Genode::Attached_dataspace *_tmp = _staged; // swap(_staged, _shared)
								_staged = _shared;
								_shared = _tmp;
								_staged_signals()->clear(); // clear new staged data, for a new bunch of signals.
								return Genode::static_cap_cast<Genode::Rom_dataspace>
								       ( _shared->cap() ); //and shared the new data.
							}

							/// Allow clients register their signal infrastructure.
							void sigh( Genode::Signal_context_capability sigh ) override
							{
								_transmitter = sigh;
							}

							/// Submit signals to clients.
							///
							/// \param signal Signal to sent to the client.
							///
							void submit( const T &signal )
							{
								_staged_signals()->add( signal ); // Add signal to _staged signal dataspace.
								_transmitter.submit(); // Notify client new signals are awaiting.
							}

							bool update() override
							{
								return false;
							}

					};

					class Root_component : public Genode::Root_component<Signal_queue_component>
					{
						private:
							char _id[64];
						public:
							Root_component( Genode::Rpc_entrypoint *ep,
							                Genode::Allocator *allocator,
							                const char *id = "descriptive_signal" ) :
								Genode::Root_component<Signal_queue_component>( ep, allocator )
							{
								Genode::strncpy( _id, id, sizeof( _id ) );
								_id[ sizeof( _id ) - 1 ] = 0;
							}

							Signal_queue_component *queue()
							{
								return _create_session( _id ) ;
							}

						protected:
							Signal_queue_component *_create_session( const char *args )
							{
								static Signal_queue_component *_queue = 0;

								if ( 0 == _queue )
									_queue = new( Genode::Root_component<Signal_queue_component>::md_alloc() )
									Signal_queue_component();

								return _queue;
							}

					};

					Root_component _root;
					Genode::Env &_env;

				public:

					/// Constructor
					///
					/// \param ep the entrypoint
					/// \param allocator an allocator
					///
					Transmitter( Genode::Env &env,
					             Genode::Allocator *allocator,
					             const char *id = "descriptive_signal" ):
						_env( env ),
						_root( _env.ep(), allocator, id )
					{
						_env.parent().announce( _env.ep().manage( &_root ) );
					}

					virtual ~Transmitter() {}

					/// Submit a signal
					///
					/// \param signal the signal
					///
					virtual void submit( const T &signal )
					{
						_root.queue()->submit( signal );
					}
			};

			///
			/// Receiver class, used by the client-programmer in order to receive
			/// signals.
			///
			class Receiver
			{
				private:
					Genode::Signal_receiver _receiver;
					Genode::Signal_context _context;
					Genode::Signal_context_capability _sig_capability;
					Genode::Attached_rom_dataspace _dataspace;

					Signal_queue *_queue;

					/// 1) Wait for signal(s) to come in
					/// 2) Retrieve the new dataspace.
					/// 3) Reset local data structures in order to start processing the data.
					void _wait_and_update_data()
					{
						_receiver.wait_for_signal();
						_dataspace.update();
						_queue = _dataspace.local_addr<Signal_queue>();
					}
				public:
					///
					/// Constructor
					///
					Receiver( const char *id = "descriptive_signal" ):
						_receiver(),
						_context(),
						_sig_capability( _receiver.manage( &_context ) ),
						_dataspace( id ),
						_queue( _dataspace.local_addr<Signal_queue>() )
					{
						_dataspace.sigh( _sig_capability );
					}

					virtual ~Receiver() {}

					/// Wait and unblock whenever a signal comes in. Call handler to process the signal.
					///
					/// \param handler handler accepting a T argument for processing.
					///
					template <typename FUN>
					void wait_and_handle( FUN handler )
					{
						_wait_and_update_data();

						for ( Csl::size_t i = 0 ; i < _queue->size(); ++i ) // .. and handle
						{
							handler( _queue->get( i ) );
						}
					}
			};
	};
} // namespace Csl


